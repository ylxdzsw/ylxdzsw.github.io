<!doctype html>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=author content=ylxdzsw@gmail.com>
<title> Method Chaining, Destructor, and Rust
 | ylxdzsw's blog</title>
<style>html{font-family:sans-serif;font-size:18px;line-height:1.5;text-align:justify;color:#33333d;-webkit-user-select:none}@media (max-width: 625px){html{font-size:14px}}body{max-width:1170px;margin:0 auto;padding:15px}h2,h3{position:relative;margin:0;padding:.8rem 0 0}h2:before,h3:before{content:"#";color:#42b983;position:absolute;left:-1rem;top:.75rem;font-size:1.2rem;font-weight:bold;opacity:0}@media (max-width: 625px){h2:before,h3:before{left:-.8rem;top:.85rem}}h2:hover:before,h3:hover:before{opacity:1}h2 a,h3 a{color:#2c3e50}h2{margin-top:0;padding-bottom:0.7rem;border-bottom:0.5px solid #ddd}h2:before{top:.9rem;font-size:1.4rem}@media (max-width: 625px){h2:before{left:-.8rem;top:1rem}}p{margin:1.2rem 0}pre{background-color:#fafaf9}code{font-family:monospace;font-size:.8rem;padding:.1rem}ul ol{padding-left:1.5rem;margin:1.2rem 0}a{color:#42b983;text-decoration:none}a:hover{text-decoration:underline}blockquote{margin:2rem 0;padding:0 1.2rem;border-left:4px solid #42b983}blockquote p{margin-left:0}
</style><h2><a id=x0 href=#x0> Method chaining</a></h2><p>Google Feeds pushed a blog post of Dave  <a href=https://daveaglick.com/posts/method-chaining-fluent-interfaces-and-the-finishing-problem><i>Method Chaining, Fluent Interfaces, and the Finishing Problem</i></a> to me yesterday. It is a good article which analyzed the finishing
problem in method chaining. However, it missed a possible solution (or workaround using his wording), which I'll discuss
in this post.
</p><p>For who are not familiar with the term, method chaining is simply something like <code>a.b().c().d()</code>, where each
method returns an object (usually <code>this</code>) for successive calls. jQuery is a good example of method chaining.
Method chaining is considered visually beautiful and clean by most people.
</p><h2><a id=x1 href=#x1> The finishing problem</a></h2><p>One of the biggest problem of method chaining is the finishing problem, as extensively discussed in Dave's blog post.
In short, the finishing problem means it is hard for the library to decide when to take an action. As in Dave's example:
</p><pre><code class=language-csharp>    Log.Message("Oh, noes!").Severity(Severity.Bad).User("jsmith");
</code></pre><p>The <code>Log</code> library does not know if it should start writing when <code>.Message</code> is called, since it might be followed
by <code>.Severity</code> or <code>.User</code>. Dave listed several workarounds, but they need either a syntax or semantic change,
except for the "casting" approach. But the "casting" approach is suboptimal as well: it introduces an unused reference,
requires a proper type to convert to, and impossible in dynamic languages like Python and Javascript.
</p><h2><a id=x2 href=#x2> The road not taken: destructor</a></h2><p>However, there is yet another option Dave did not mention, and it does not need to change the syntax and does exactly what
is expected: taking action directly after the chain ends. The idea is, well, taking action in the <i>destructor</i> (or
finalizer in some languages). Here is a short example in Python.
</p><pre><code class=language-python>class Log():
    def __init__(this):
        this._message = ""
        this._severity = "debug"
    def message(this, x):
        this._message = x
        return this
    def severity(this, x):
        this._severity = x
        return this
    def __del__(this):
        print(f"{this._severity}: {this._message}")

def main():
    print("start")
    Log().message("message1").severity("info")
    Log().message("message2")
    print("end")

main()
</code></pre><p>Looks crazy, unreliable, and an abuse of the destructor? Yes, but only because it is written in Python, and Python does
not make clear promise on when and how the destructors are called (or at least most Python programmers do not know). With
a little formalization this crazy idea can become a super powerful technique, and that's Rust.
</p><h2><a id=x3 href=#x3> Scope, "with", and lifetime</a></h2><p>Before advertisements of Rust, we first explain what happened in the above code. Here is the pseudo code that shows the
implicit function calls in <code>main</code>:
</p><pre><code class=language-c>    print("start")
    a = malloc(Log)
    Log::__init__(a)
    Log::message(a, "message1")
    Log::severity(a, "info") # this is the last explicit reference to `a`
    Log::__del__(a)
    free(a)
    b = malloc(Log)
    Log::__init__(b)
    Log::message(b, "message2")
    Log::__del__(b)
    free(b)
    print("end")
</code></pre><p>I use <code>malloc/free</code> to show the memory allocation, but they are not necessarily in allocated in heap. An insane
optimizer might even make them in the same memory, since <code>a</code> dies before <code>b</code> is born.
</p><h2><a id=x4 href=#x4> Rust</a></h2>