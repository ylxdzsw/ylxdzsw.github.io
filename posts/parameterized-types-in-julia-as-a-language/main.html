<!DOCTYPE html><html lang="zh_CN"><head><meta charset="utf8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>像一门语言一样使用julia的参数化类型 | ylxdzsw's blog</title><link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,600|Roboto+Mono' rel='stylesheet' type='text/css'><script src="/lib/zepto.js"></script><link rel="stylesheet" href="/lib/prism.css"/><script src="/lib/prism.js"></script><link rel="stylesheet" href="/nattoppet/vue.css"/><script src="/nattoppet/vue.js"></script></head><body><h2 id="-julia-">像一门语言一样使用julia的参数化类型</h2>
<h3 id="-">参数化类型</h3>
<p>参数化类型是julia类型系统的一个重要部分，最基本的类型像数组<code>Array{T,N}</code>就用到了类型参数，其中T表示元素的类型，而N为数组的维度。
例如<code>Array{Int, 1}</code>表示一维的整数数组，<code>Array{Rational, 2}</code>表示一个有理数矩阵。</p>
<p>julia的参数化类型和一般的泛型相比，其强大之处在于</p>
<ol>
<li>类型参数不一定是其它类型，还可以是整数、浮点数、符号(Symbol类型)甚至用户自定义的immutable类型。</li>
<li>参数包含参数化类型的函数，可以通过模式匹配获得参数化类型的类型参数，例如函数<code>dims{N}(::Array{Int,N})=N</code>返回整数数组的维度。</li>
</ol>
<h3 id="-erlang-">与Erlang比较</h3>
<p>Erlang是一门经典的函数式语言，它通过模式匹配+递归来组织程序流程，这恰好和julia的类型分派相似，这使得我们可以将一些Erlang程序&quot;直译&quot;成使用参数化类型的julia代码。</p>
<p>要&quot;直译&quot;Erlang代码，我们首先定义几个&quot;基本类型&quot;和&quot;基本操作&quot;，这些在这整篇博文中都会用到</p>
<pre><code class="lang-julia">immutable Atom{X} end
immutable List{H, T} end

Atom(x) = Atom{x}

List() = List{}
List(x) = List{x, List{}}
List(x, t...) = List{x, List(t...)}

+{a, b}(::Type{Atom{a}}, ::Type{Atom{b}}) = Atom{a+b}
-{a, b}(::Type{Atom{a}}, ::Type{Atom{b}}) = Atom{a-b}
*{a, b}(::Type{Atom{a}}, ::Type{Atom{b}}) = Atom{a*b}
/{a, b}(::Type{Atom{a}}, ::Type{Atom{b}}) = Atom{a/b}
</code></pre>
<p>其中<code>atom</code>和<code>list</code>的概念都是来自于Erlang(<a href="http://erlang.org/doc/getting_started/seq_prog.html">链接</a>)，其中List()对应Erlang的list，而List{}对应Erlang的tuple</p>
<p>通过这两个类型，我们使用下面的规则来&quot;直译&quot;Erlang代码</p>
<ul>
<li>函数形参中，<code>X</code> -&gt; <code>Type{Atom{X}}</code>，<code>[]</code> -&gt; <code>Type{List{}}</code>，<code>[H|T]</code> -&gt; <code>Type{List{H, T}}</code></li>
<li>函数调用时，<code>X</code> -&gt; <code>Atom(X)</code>，<code>[]</code> -&gt; <code>List()</code>，<code>[a, b, ...]</code> -&gt; <code>List(a, b, ...)</code>，<code>{x, y}</code> -&gt; <code>List{x, y}</code></li>
</ul>
<p>下面是来自<a href="">http://erlang.org/doc/getting_started/seq_prog.html</a>的几个例子</p>
<h3 id="-">阶乘</h3>
<ul>
<li>Erlang</li>
</ul>
<pre><code class="lang-erlang">fac(1) -&gt;
    1;
fac(N) -&gt;
    N * fac(N - 1).
</code></pre>
<pre><code class="lang-erlang">6&gt; fac(4).
24
</code></pre>
<ul>
<li>julia参数化类型</li>
</ul>
<pre><code class="lang-julia">fac(::Type{Atom{1}}) = Atom(1)
fac{N}(::Type{Atom{N}}) = Atom(N) * fac(Atom(N-1))
</code></pre>
<pre><code class="lang-julia">julia&gt; fac(Atom(4))
Atom{24}
</code></pre>
<h3 id="-">求列表长度</h3>
<ul>
<li>Erlang</li>
</ul>
<pre><code class="lang-erlang">list_length([]) -&gt;
    0;    
list_length([First | Rest]) -&gt;
    1 + list_length(Rest).
</code></pre>
<pre><code class="lang-erlang">29&gt; list_length([1,2,3,4,5,6,7]).
7
</code></pre>
<ul>
<li>julia参数化类型</li>
</ul>
<pre><code class="lang-julia">list_length(::Type{List{}}) = Atom(0)
list_length{First, Rest}(::Type{List{First, Rest}}) = Atom(1) + list_length(Rest)
</code></pre>
<pre><code class="lang-julia">julia&gt; list_length(List(1,2,3,4,5,6,7))
Atom{7}
</code></pre>
<h3 id="-">稍微复杂一点的例子</h3>
<ul>
<li>Erlang</li>
</ul>
<pre><code class="lang-erlang">format_temps([])-&gt;                        % No output for an empty list
    ok;
format_temps([City | Rest]) -&gt;
    print_temp(convert_to_celsius(City)),
    format_temps(Rest).

convert_to_celsius({Name, {c, Temp}}) -&gt;  % No conversion needed
    {Name, {c, Temp}};
convert_to_celsius({Name, {f, Temp}}) -&gt;  % Do the conversion
    {Name, {c, (Temp - 32) * 5 / 9}}.

print_temp({Name, {c, Temp}}) -&gt;
    io:format(&quot;~-15w ~w c~n&quot;, [Name, Temp]).
</code></pre>
<pre><code class="lang-erlang">36&gt; format_temps([{moscow, {c, -10}}, {cape_town, {f, 70}},
{stockholm, {c, -4}}, {paris, {f, 28}}, {london, {f, 36}}]).
moscow          -10 c
cape_town       21.11111111111111 c
stockholm       -4 c
paris           -2.2222222222222223 c
london          2.2222222222222223 c
ok
</code></pre>
<ul>
<li>julia参数化类型</li>
</ul>
<pre><code class="lang-julia">format_temps(::Type{List{}}) = Atom(:ok)
format_temps{City, Rest}(::Type{List{City, Rest}}) = begin
    print_temp(convert_to_celsius(City))
    format_temps(Rest)
end

convert_to_celsius{Name, Temp}(::Type{List{Name, List{Atom{:c}, Temp}}}) = begin
    List{Name, List{Atom(:c), Temp}}
end
convert_to_celsius{Name, Temp}(::Type{List{Name, List{Atom{:f}, Temp}}}) = begin
    List{Name, List{Atom(:c), (Temp - Atom(32)) * Atom(5) / Atom(9)}}
end

print_temp{Name, Temp}(::Type{List{Atom{Name}, List{Atom{:c}, Atom{Temp}}}}) = begin
    @printf(&quot;%-15s %f c\n&quot;, Name, Temp)
end
</code></pre>
<pre><code class="lang-julia">julia&gt; format_temps(List(List{Atom(:moscow), List{Atom(:c), Atom(-10)}},
                         List{Atom(:cape_town), List{Atom(:f), Atom(70)}},
                         List{Atom(:stockholm), List{Atom(:c), Atom(-4)}},
                         List{Atom(:paris), List{Atom(:f), Atom(28)}},
                         List{Atom(:london), List{Atom(:f), Atom(36)}}))
moscow          -10.000000 c
cape_town       21.111111 c
stockholm       -4.000000 c
paris           -2.222222 c
london          2.222222 c
Atom{:ok}
</code></pre>
<p>可以看到由于语法的问题，julia的代码视觉干扰比较严重(通过宏可以解决)，但是功能上已经可以完成很多工作了，绝不只是能用来声明一个集合的元素类型。</p>
</body></html>