mixin afuckingtable
	table.Hcenter&attributes(attributes)
		tr
			td 01
			td 02
			td 03
			td 04
		tr
			td 05
			td 06
			td 07
			td 08
		tr
			td 09
			td 10
			td 11
			td 12

doctype html
html
	head
		meta(charset='utf8')
		meta(name="author", content="ylxdzsw")
		title 流与惰性求值
		style
			include jquery.fullPage.css
		style
			include bootstrap.min.css
		style
			include prism.css
		script
			include jquery-1.11.2.min.js
		script
			include jquery.fullPage.min.js
		script
			include bootstrap.min.js
		script
			include prism.js
		style.
			body {
				color: #F8F8F2;
				font-family: Consolas, "楷体", monospace;
				background-color: #343434;
			}

			.Hcenter {
				margin: auto;
			}

			h1 {
				font-size: 10vmin;
				text-align: center;
			}

			h2 {
				font-size: 5.5vmin;
				text-align: center;
			}

			h3 {
				font-size: 5vmin;
			}

			p {
				font-size: 4vmin;
				text-indent: 8vmin;
			}

			ul {
				font-size: 4vmin;
			}

			.subtitle {
				font-size: 5vmin;
				text-align: left;
			}

			.title {
				font-size: 6vmin;
				position: absolute;
				text-align: center;
				top: 5%;
				width: 100%;
			}

			.main-point {
				text-align: center;
				font-size: 12vmin;
			}

			.high-light {
				color: mediumaquamarine;
			}

			#fp-nav span {
				background-color: mediumaquamarine !important;
			}

			.fp-controlArrow {
				display: none !important;
			}

			pre[class*="language-"] {
				margin: .5em .5em !important;
			}

			td {
				text-align: center;
				font-size: 4vmin;
				padding: 2vmin;
				border: solid 1px;
			}

			code {
				font-size: 3vmin !important;
			}
		script
			:coffee
				$ ->
					$("#fullpage").fullpage
						navigation: on
						navigationPosition: 'right'
						slideNavigation: on
						loopHorizontal: no
	body
		#fullpage
			#page1.section.container-fluid
				h1 流与惰性求值
				h1.subtitle.col-sm-offset-5 Stream and Lazy Evaluation (in js)
			#page2.section.container-fluid
				h1.title 函数式与命令式
				.slide
					h2 求表中数字的和
					+afuckingtable#table1
				.slide
					h2 求表中数字的和
					.col-sm-6
						pre: code.language-javascript.
							var nodes = document.querySelectorAll('#table1 td');
							var sum = 0;
							for(var i = 0; i < nodes.length; i += 1) {
								var value = nodes[i].textContent
								sum += Number(value)
							}
							console.log(sum);
					.col-sm-6
						pre: code.language-javascript.
							var nodes = document.querySelectorAll('#table1 td');
							var sum = [].map.call(nodes,function(x){
								return Number(x.textContent);
							}).reduce(function(x,y){
								return x+y;
							});
							console.log(sum);
				.slide
					pre: code.language-javascript.
						// repo: dog-fucked-zhihu, author: winter
						// https://github.com/wintercn/dog-fucked-zhihu/
						var h = setInterval(function(){
							if($('.zu-button-more').length) {
								$('.zu-button-more')[0].click();
							} else {
								clearInterval(h);
								var questions = Array.prototype.slice.call($('.question_link'))
									.filter(function(e){return e.previousSibling.textContent.match(/回答了问题/)})
									.map(function(e){return e.href})
									.join('\n')
								console.log(questions);
							}
						},500)
			#page3.section.container-fluid
				h1.title js中的函数式
				.col-sm-6
					h2 已经有的
					ul
						li 高阶函数
						li 匿名函数 
						li 词法作用域/闭包
						li map reduce some filter...
				.col-sm-6
					h2 还缺的
					ul
						li 尾递归优化(ES6)
						li 模式匹配
						li 列表推导
						li 类型推导
						li 更多原生支持
				style.
					#page3 ul{
						text-align: center;
						list-style-type: none;
					}
					#page3 ul li {
						transition: color 0.5s;
					}
				script
					:coffee
						$ ->
							nodes = document.querySelectorAll("#page3 li")
							looper = (x) ->
								document.getElementById('page3').onclick = ->
									$(nodes[x]).addClass 'high-light'
									$(nodes[x-1]).removeClass 'high-light' if x
									return looper x+1 if x < nodes.length
									looper 0
							looper 0
			#page4.section.container-fluid
				h1.title 函数式与命令式
				.slide
					h2 点击弹出数字-命令式
					.col-sm-8
						pre: code.language-javascript.
							var nodes = document.querySelectorAll('#table2 td');
							for (var i = 0; i < nodes.length; i += 1) {
								nodes[i].onclick = function(){
									alert(nodes[i].textContent);
								}
							}
					.col-sm-4
						+afuckingtable#table2
						script.
							$(function(){
								var nodes = document.querySelectorAll('#table2 td');
								for (var i = 0; i < nodes.length; i += 1) {
									nodes[i].onclick = function(){
										alert(nodes[i].textContent);
									}
								}
							});
				.slide
					h2 点击弹出数字-函数式
					.col-sm-8
						pre: code.language-javascript.
							var nodes = document.querySelectorAll('#table3 td');
							[].map.call(nodes,function(x){
								x.onclick = function(){
									alert(x.textContent)
								}
							});
					.col-sm-4
						+afuckingtable#table3
						script.
							$(function(){
								var nodes = document.querySelectorAll('#table3 td');
								[].map.call(nodes,function(x){
									x.onclick = function(){
										alert(x.textContent)
									}
								});
							});
			#page5.section.container-fluid
				h1.title 事情不总是美好的
				.slide
					h1.main-point
						| 优雅的代价：<span class="high-light">性能</span>
				.slide
					h2 找到5个大于5的数
					.col-sm-8
						pre: code.language-coffeescript.
							[].slice.call(document.querySelectorAll '#table4 td')
								.map (x) -> x.textContent
								.map Number
								.filter (x) -> x>5
								.slice 0,5
					.col-sm-4
						+afuckingtable#table4
			#page6.section.container-fluid
				h1.main-point 流：函数式的用法
				h1.sub.col-sm-offset-5 命令式的性能
				style.
					#page6 .sub {
						font-size: 12vmin;
					}
			#page7.section.container-fluid
				h1.title 流如何工作
				.slide
					h2 流的结构定义
					pre: code.language-coffeescript.
						class Stream
							constructor: (@h,@t) ->
					p h表示流当前的值，而t是流的核心：它表示一个求值承诺(不是js的promise)，当需要的时候，你就可以得到它的值
				.slide
					h2 流的实现机理
					h3 两个关键步骤：<span class="high-light">delay</span>和<span class="high-light">force</span>
					p delay生成一个求值承诺，而force使用求值承诺获得值
					h3 实现方法：
					pre: code.language-coffeescript.
						delay = (x) -> x # x是求值方法(其实就是函数)
						force = (x) -> x() # x是求值承诺(其实也是函数)
				.slide
					h2 重要优化
					pre: code.language-coffeescript.
						memo_proc = (f) ->
							is_already_run = no
							result = null
							() ->
								if not is_already_run
									is_already_run = yes
									result = do f
								result
						delay = (x) -> memo_proc x
			#page8.section.container-fluid
				h1.title 示例：整数区间流
				pre: code.language-coffeescript.
					enumerate_interval = (low=0, high) ->
						return null if low >= high
						new Stream low, -> enumerate_interval low+1, high

					integer = enumerate_interval()
			#page9.section.container-fluid
				h1.title 流操作-简单操作
				.slide
					h2 head & tail
					.col-sm-6
						pre: code.language-coffeescript.
							Stream::head = () -> @h
							Stream::tail = () -> @t()
					.col-sm-6
						pre: code.language-coffeescript.
							integer.head() # 0
							integer.tail().head() # 1
				.slide
					h2 ref
					.col-sm-6
						pre: code.language-coffeescript.
							Stream::ref = (x) ->
								return @h if x is 0
								tail = @t()
								throw new Error 'stream exhausted' if not tail?
								tail.ref x-1
					.col-sm-6
						pre: code.language-coffeescript.
							enumerate_interval(10,20).ref(4) # 14
			#page10.section.container-fluid
				h1.title 流操作-管道操作
				.slide
					h2 filter
					.col-sm-6
						pre: code.language-coffeescript.
							Stream::filter = (f) ->
								if f @h
									new Stream @h, => @t()?.filter f
								else
									@t()?.filter f
					.col-sm-6
						pre: code.language-coffeescript.
							integer.filter (x) -> x % 2 # 奇数流
							integer.filter (x) -> x < 10 # 读取这个流的第10个元素会死循环/溢出
				.slide
					h2 map
					.col-sm-6
						pre: code.language-coffeescript.
							Stream::map = (f) ->
								new Stream f(@h), -> @t()?.map f
					.col-sm-6
						pre: code.language-coffeescript.
							integer.map (x) -> x + 1 # 正整数流
							integer.map (x) -> -x - 1 # 负整数流
				.slide
					h2 limit
					.col-sm-6
						pre: code.language-coffeescript.
							Stream::limit = (x) ->
								if x <= 0
									null
								else
									new Stream @h, => @t()?.limit x-1
					.col-sm-6
						pre: code.language-coffeescript.
							integer.limit(5) # 0,1,2,3,4的流
				.slide
					h2 管道操作特点
					.col-sm-offset-1
						ul
							li 是流的方法，生成的是新的流
							li 可以处理无穷的流
							li 不会引发求值，但是会提高求值时的性能压力
							li 无状态：不能根据流以前的值来影响后续的值(可以用闭包变量/全局变量来引入状态(如.unique()))
							li 管道操作一般实现方法：操作头元素，同时将自己包含进后续求值承诺
			#page11.section.container-fluid
				h1.title 流操作-归约操作
				.slide
					h2 reduce
					.col-sm-6
						pre: code.language-coffeescript.
							Stream::reduce = (f) ->
								x = @h
								y = @t()
								while y?
									x = f x, y.head()
									y = y.tail()
								x
							# almost quivalent
							Stream::reduce = (f) ->
								@toArray().reduce(f)
					.col-sm-6
						pre: code.language-coffeescript.
							integer
								.limit 5
								.reduce (x,y) -> x+y
				.slide
					h2 toArray
					.col-sm-6
						pre: code.language-coffeescript.
							Stream::toArray = ->
								handle = @
								while handle?
									result = handle.head()
									handle = handle.tail()
									result
					.col-sm-6
						pre: code.language-coffeescript.
							integer.limit(5).toArray() # [0,1,2,3,4]
							integer.toArray() # 死循环/溢出
				.slide
					h2 归约操作特点
					.col-sm-offset-4
						ul
							li 处理流，生成结果(一般不再是流)
							li 通常不能操作无穷流
							li 会触发求值
							li 一般需要遍历流
			#page12.section.container-fluid
				h1.title 流操作-组合操作
				.slide
					h2 zip
					.col-sm-6
						pre: code.language-coffeescript.
							zip = (streams...) ->
								if streams.some is_exhausted
									null
								else
									heads = streams.map (x) -> x.head()
									new Stream heads, ->
										tails = streams.map (x) -> x.tail()
										zip tails...
					.col-sm-6
						pre: code.language-coffeescript.
							zip(integer,integer)
								.map ([x,y]) -> x*y
								.limit 5
								.toArray()
							# [0,1,4,9,16]
				.slide
					h2 stream-map
					.col-sm-6
						pre: code.language-coffeescript.
							stream-map = (f,streams...) ->
								zip(streams...).map (x) -> f x...
					.col-sm-6
						pre: code.language-coffeescript.
							op_add = (x,y) -> x+y
							stream-map op_add, integer, integer #偶数流，相当于integer.filter is_even
			#page13.section.container-fluid
				h1.title 流的生成-递归法
				pre: code.language-coffeescript.
					seive = (s) -> new Stream_with_memo s.head(), -> seive s.tail()?.filter (x) -> x % s.head() isnt 0
					primes = seive enumerate_interval 2
				p 递归法可以轻易地生成无穷流，其核心是在构造的流的求值承诺里面调用自身
			#page14.section.container-fluid
				h1.title 流的生成-隐式定义
				pre: code.language-coffeescript.
					fibs = new Stream 0, ->
						new Stream 1, ->
							zip(fibs,fibs.tail())
								.map ([x,y]) -> x+y
				p 在正统函数式语言(Haskell)里的写法：
				pre: code.language-coffeescript.
					fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
				p 隐式定义的核心其实也是递归：在定义中包含自身，从而不断地生成下去
			#page15.section.container-fluid
				h1.title 流的生成-生成器
				.slide
					h2 ECMAScript6 Generator
					pre: code.language-coffeescript.
						make_stream_by_generator = (g) ->
							g = g() if g instanceof GeneratorFunction_t
							x = g.next()
							if x.done
								null
							else
								new Stream_with_memo x.value, -> make_stream_by_generator g
				.slide
					h2 例子-流式快排
					pre: code.language-coffeescript.
						stream_sort = (x) ->
							x = x.toArray() if x instanceof Stream #TODO: will crash with infinity stream
							iter = `function*(x){
								if(x.length === 0){return null}
								if(x.length === 1){yield x[0];return null}
								middle = x[0]; // can be optimized
								left = x.filter(function(i){return i < middle});
								right= x.slice(1).filter(function(i){return i >= middle});
								for (i of iter(left)) { yield i	}
								yield middle;
								for (i of iter(right)) { yield i }
							}` # coffee lacks of the "of" notation to iter generators
							make_stream_by_generator iter x
			#page16.section.container-fluid
				h1.main-point 然而并没有什么卵用？
			#page17.section.container-fluid
				h1.title 哪些地方有流
				ul.col-sm-offset-1
					li 微软C#力推的新写法Linq是非函数式语言里流的最优雅实现
					li R语言的参数求值也默认是惰性的
					li Haskell,Ocaml,Clojure等函数式流派的语言就不用说了
					li Python的生成器也是流的重要用法(js也有yield了(ECMA 6))
					li ......
			#page18.section.container-fluid
				h1.title 为什么使用流
				ul.col-sm-offset-2
					li 优雅，可读，专注于目的而不是手段
					li 在性能和写法上取得平衡
					li 避免造轮子
					li.high-light 提供看问题的新角度
			#page19.section.container-fluid
				h1.title 写法的不同导致思路的不同
				pre: code.language-javascript.
					mouseEvents = Lazy(sourceElement).on("mousemove")
					coordinates = mouseEvents.map (e) ->
					  elementRect = sourceElement.getBoundingClientRect();
					  [
					    Math.floor(e.clientX - elementRect.left),
					    Math.floor(e.clientY - elementRect.top)
					  ]
					# For events on one side of the element, display the coordinates in one place.
					coordinates
					  .filter (pos) -> pos[0] < sourceElement.clientWidth / 2
					  .each (pos) -> displayCoordinates leftElement, pos
					# For those on the other side, display them in a different place.
					coordinates
					  .filter (pos) -> pos[0] > sourceElement.clientWidth / 2
					  .each (pos) -> displayCoordinates rightElement, pos
			#page20.section.container-fluid
				h1.title 应用场景举例
				.slide
					h2 惰性JSON解析
					p 使用Web Service API的时候经常会出现JSON，而我们并不需要使用到其中全部的内容。如果按照通常的方法解析，任何一处的错误都会导致解析异常，从而程序无法进行。如果采用惰性解析，把JSON的解析结果变成流，这样的话只要主体部分无错，其他部分的语法错误不会导致解析停止。
				.slide
					h2 惰性字符串处理
					p String::split,String::match等方法会处理整个字符串，而我们有时并不需要这么做：我们可能只需要找到前5行，或者前5个邮件地址。
				.slide
					h2 迭代式精化过程
					p 数值方法计算，机器学习等算法采用迭代式逼近的思路，将这个过程抽象成流可以避免引入状态和赋值，从而使用函数式的风格实现这些算法。
				.slide
					h2 应用场景特点
					p 没有全部求值是流的核心，也是使用流的最大意义。如果一个场合需要对所有的元素进行计算，不能使用.limit的话，使用流是多此一举。
			#page21.section.container-fluid
				h1.title 流的扩展
				.slide
					h2 状态流
					p 状态流是指求值承诺依赖于外部状态(变量)的流，一般需要避免
					ul
						li 由于流的求值在时间上和次数上(记忆优化)的不确定性，引入状态和赋值极易引发错误
						li 如果只是要记忆流之前的状态，.reduce方法和"错位zip法"通常可以解决(见斐波那契例)
						li 一般用于有副作用的流(如使用.each进行归约的流)
				.slide
					h2 异步流
					pre: code.language-coffeescript.
						force_sync = (x) -> x() #同步方法
						force_async = (x,cb) -> x(cb) #异步方法
					p 异步流可以将求值承诺绑定到事件，通常是IO事件(node)或者UI事件(前端)
			#page22.section.container-fluid
				h1.title 如何使用流
				ul.col-sm-offset-2
					li Lazy.js
					li Stream.js
			#page23.section.container-fluid
				h1.main-point 有问题么？