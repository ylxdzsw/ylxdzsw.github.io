## Solidity 踩坑笔记

第一次听说以太坊的时候，我还是觉得很不屑的。比特币一开始就伴随着脚本出现，并且靠它实现了多签名等花式玩法，更是后面隔离见证和闪电网络的基石，可以说是非常有预见性的一个设计。而以太坊不过是给它加了一些指令，再撸了一大堆轮子称为所谓的生态，很有强行吹逼抬价格的态势。

不过不管有多少坑，有多少人骂，有多少竞争对手各方面都比他好，以太坊总算是活了下来，并且稳居第二大币之位，近期应该是很难倒了。作为一个幸存者，总是有值得学习的地方，而且也为了将来跟人吹逼方便，我决定试试用Solidity写个智能合约，体验一下传说中的Dapp。

### 制定目标：2048

网上搜了一圈，现在的智能合约应用其实极其同质化，抄来抄去抄的最多的基本可以分成三类：

- 代币类，各种ICO改来改去都跟官网那个Demo区别不大，无非就是锁仓烧币啥的。
- 猫类，或者各种宠物/卡牌/家园游戏，总之就是庞氏骗局，炒到一定程度就不会有人买了。何况这猫一点也不萌。
- 对赌类，大乐透啦，赌区块链数据啦什么的。

当然，还有从官网例子改的各种会议、投票、拍卖什么的。我也打算做一个游戏，当然不是那种抽奖拍卖类，而是游戏王或者Advance Wars By Web那样的。基本思路就是发布一个智能合约实例来开始一场游戏，其他人可以加入到其中，每一步都将自己的操作提交到智能合约上，通过搜集一些熵让矿工来处理随机事件以及游戏逻辑。这样和传统的通过对战平台玩相比有几个好处，首先它们对延迟并不是太敏感，以太坊一笔交易通常要数十秒来处理，对这几个游戏体验影响不算太大。其次每次对战都由矿工认证，可以用于很严肃的比赛，不用担心有人作弊，回访还会永久保存。再次还可以来赌博，毕竟像大乐透那种，既然都是密码学支撑的随机了，明知期望严格小于0的情况下还去赌的人就不那么多了。而通过游戏来的话，每个人都会觉得自己更胜一筹，觉得下盘能赢的心理就会更强一些。

这样的机制有一个小问题，就是区块链是透明的。以游戏王为例的话，如果由矿工来抽卡，对方可以直接从区块链上看到你的牌组啊手牌啊什么的。不过这个问题可以解决，就是开局双方都生成一个随机种子，并且把哈希提交上去。之后使用固定的随机算法，通过自己的种子和每一步矿工发布的随机数来进行随机。在结束的时候双方再发布自己的随机种子，矿工重演一下所有的随机数确认没有人作弊。这样每个人没办法预知自己的下一张牌，因为需要用到矿工发布的随机数；不知道对方的情况，因为要到游戏结束对方才会提交卡组啊、随机种子什么的。而自己又不能随意改变这些，否则在游戏结束的时候通不过验证。

然而思考了半天，最后查了一下gas的价格，顿时觉得前面全都白想了。一笔交易稍微复杂一点就要将近10刀，一盘AWBW打下来估计上千美元了，这种手续费下要赌只能是100ETH以上的大手笔还差不多，受众面也太小了。思考来思考去，觉得这样的对战游戏似乎根本没法有效地实现，只好退而求其次，做个单机游戏。单机游戏肯定要随机数扮演重要角色，不然就没什么可玩的了。理想状态下，应该要让胜负基本由随机数决定，但是又让玩家感觉自己的技巧在发挥作用。

最后选择了2048。它的策略非常简单，有经验的玩家基本可以把把达成1024，但是又很难上4096或者更高。只需要开局的时候支付赌注，然后矿工会发一个随机数过来，然后玩家就自己high，玩完了之后将replay交给矿工验证，因为使用同一个随机数种子和随机算法，矿工可以再现整个局并且计算得分，然后通过得分来发放奖励。这样一共只要两个交易，而且第一个交易基本没有什么计算，总的成本大概一局15美元左右，还是勉强可以接受的。

这样只有一个问题，就是玩家可以悔棋：因为只是开局的时候拿到随机种子，之后就自己玩，所以总是可以预知之后的随机数，从另一个角度说就是可以无限悔棋，甚至自己写软件来暴力搜索。不太清楚如果没把都使用最优策略平均能拿到多少分，不过考虑到智能合约里的钱就那么多，要是有玩家逆天的话也只是提交失败而已，我反正怎么都不可能亏钱¯_(ツ)_/¯。

### 以太全家桶

以太坊一个让我很不喜欢的地方就是轮子多，概念多，花了好长时间才勉强捋顺这一堆东西：

- Gas：其实就是手续费，每笔交易需要支付 `gas limit` * `gas price` 的费用。为什么不直接设定手续费，而是要设定两个数呢，并不知道。我能想到的唯一好处就是`gas limit`可以单独估计，不受行情影响。不过总之并不需要先去购买一个叫Gas的东西，这也是我刚开始困扰了很久的东西。其实大可把Gas当成一个虚概念，它只是计算时用的，实际交易还是以ETH支付手续费。值得注意的是如果Gas不够导致交易失败了，交易会回卷，就像从来没有发出过一样，但是手续费是拿不回来的。这点和BTC不一样，BTC手续费不够就一直挂着等到有好心矿工来为止。
- EVM：高大上的以太虚拟机，或者也可以看作智能合约的解释器。除了知道它性能很差以外，没有什么需要注意的。
- Solidity：一个轮子语言，用来编译成智能合约的。网上都说像Javascript，我倒觉得更像C。最大的特点是坑多，反直觉。好在有个Linter还算给力，还有Remix也省了不少事。
- Remix：一个在线IDE，可以编译Solidity并且发送到以太网络上去。还有个debugger，虽然体验一般，但是功能还是有的。编译那里也可以把ABI复制下来，所以有了这个东西基本上什么都不用装了。
- web3：一个API库，用来调用与以太网络相关的操作，比如发起交易啊，在链上搜索什么的。它使用自有协议和以太坊节点通信。
- Metamask：一个浏览器插件，可以注入web3到每个网页上。基本可以看作一个以太坊钱包并且自带一个web3库。

### 合约设计

Solidity里一个contract可以看成一个类，由一些成员变量(称为state variable)和方法组成。一个合约可以创建多次，每次都会形成不同的合约实例，有着各自的地址，互不相干。

对我的2048来说，显然不需要太复杂的分解，使用究极设计模式`God Object`模式就足够了。

首先要选择的是一个大实例还是每次游戏都创建一个新实例。一个大实例是说我一次性创建一个合约实例，之后每个人游戏都调用其中的一个方法来开始一次新游戏，在这个合约里使用一个mapping来保存正在进行的游戏的情况。每次都创建新实例是说把智能合约的代码或者编译好的程序放在里面，玩家自己上传创建一个实例然后玩。但是后者有一个问题，就是我没办法及时打钱进去：玩家肯定是冲着赚我的钱来的，但是他们自己创建的合约里面并没有我的钱。想了一会儿没找到什么好办法，就选择了使用一个大实例的方案。

那么总的合约看起来是这样的：

```
pragma solidity ^0.4.21;

contract D2048 {
    mapping(bytes32 => uint16) public scores;

    event Game(address player, uint time, uint32 seed);
    event Score(address player, uint time, uint16 score);

    function start_game() payable public {
        ...
        emit Game(...)
    }

    function submit(uint time, uint16 score, bytes solution) public {
        ...
        emit Score(...)
    }

    function refund(uint amount) public returns (string) {...}
```

玩家调用`start_game()`来开启一场新游戏并且支付赌注，矿工根据打包时间和玩家地址生成一个随机种子并且广播出去。注意使用时间作为随机种子，矿工可以在一定范围内进行调整以便生成想要的种子，因此Solidity官方也不建议这么做。不过显然不会有矿工大费周章去攻击我这种垃圾游戏。

之后玩家使用得到的随机种子进行游戏，并且记录整个游戏步骤。游戏结束后将步骤上传到`submit`方法，矿工再重演整个游戏过程，如果没有出现错误的话再将和游戏得分相关的奖励发放回玩家。如果出现错误，比如玩家自行修改了客户端程序造成了不同步的游戏，就自动回卷整个交易，玩家要么只能自己拿着种子再玩一遍正常的游戏，反正不通过的方案肯定是提交不上的。

最后是我的提币后门。设计上必然是我要盈利的，那么我得留一个函数让我把钱提出来。这个函数只要检查发起人是不是我就行了，如果是就转账。

#### Modifier
#### 事件
#### 随机数
